require("dotenv").config()
const fs = require('fs')
const {MongoClient} = require('mongodb')
const { spawn } = require('child_process')
const { Command } = require("commander")

function cleanup(object){
    Object.entries(object).forEach(([k, v])=>{
        if (v && typeof v ==='object'){
            cleanup(v);
        }
        if (v && typeof v ==='object' && !Object.keys(v).length || v===null || v === undefined || v === '' || k === '__typename' || v === 'none' || (Object.keys(object).length===1 && typeof v === 'boolean' && !v)) {
            if (Array.isArray(object)) {
                object.splice(k, 1)
            } else if (!(v instanceof Date)) {
                delete object[k];
            }
        }
    })
    return object
}

function setEquivalent(setA, setB){
    return setA.size === setB.size && [...setA].every((x)=> setB.has(x))
}

const zipUp = async (folder, resultName = null) => {
    // zips and encrypts full body json documents generated by browser
    let ds = (new Date()).toLocaleDateString().replaceAll("/", "_")
    if (!folder.endsWith("/") )folder += "/"
    let archiveId =  resultName || folder.slice("/app/tmp/collections/".length).replaceAll("/", "_")
    var tarCmd = spawn("tar", ["--remove-files", "-cvzf", "-", folder])
    var gpgCmd = spawn("gpg", ["--output", `/app/tmp/collections/${archiveId + ds}.tar.gz.gpg`, '--trust-model', 'always', '--encrypt', '--recipient', process.env.EMAIL])
    tarCmd.stdout.pipe(gpgCmd.stdin);
    tarCmd.stderr.on("data", (data)=> console.log(data.toString()))
    tarCmd.on("close", (code)=> {console.log('tar process exited with code ', code); gpgCmd.stdin.end()})
    gpgCmd.stderr.on("data", (data)=> console.log(data.toString()))
    gpgCmd.on("close", (code)=> {console.log('gpg process exited with code ', code);})

}

const decryptAndExtract = (file=undefined) => {
    let ds = file || (new Date).toLocaleDateString().replaceAll("/", "_")
    var gpgCmd = spawn("gpg", ["-d", `${ds}.tar.gz.gpg`])
    var tarCmd = spawn("tar", ["-xvzf", "-"])
    gpgCmd.stdout.pipe(tarCmd.stdin)
    gpgCmd.stderr.on("data", (data)=> console.log("gpgCmd stderr => ", data.toString()))
    gpgCmd.on("close", (code)=> {
        console.log('gpg process exited with code ', code);
        tarCmd.stdin.end(); 
    })
    tarCmd.stderr.on("data", (data)=> console.log("tarCmd stderr => ", data.toString()))
    tarCmd.on("close", (code)=> console.log("tar process exited with code ", code))
}

function insertData(listOfObjects, collectionName, mock=false){
    if (listOfObjects.length===0) {
        throw new Error("bulkWrite Operations Cannot Write an Empty list or Parse an empty string!")
    } else if (typeof(listOfObjects)==='string' ){
        if (!fs.existsSync(listOfObjects)) throw new Err("file does not exist");
        listOfObjects = JSON.parse(fs.readFileSync(listOfObjects))
    } 
    const client = new MongoClient(process.env.MONGO_CONN_URL)
    const dbName = 'new'

    async function main(){
        await client.connect();
        console.log('Connected successfully to server')
        const db = client.db(dbName)
        const collection = db.collection(collectionName);
        if (!mock){
            let cursor = await collection.insertMany(listOfObjects)
            console.log(`inserted ${cursor.insertedCount} into ${collectionName}`)
        } else {
            console.log("wouldve inserted ", listOfObjects.length, " into ", collectionName)
        }
        
        return 'done.'
    }

    main()
        .then(console.log)
        .catch(console.error)
        .finally(()=> client.close())
}

async function insertFilteredData(id, collectionName, newData = undefined, dbName = 'new', mock=false){
    if (newData.length===0) {
        throw new Error("bulkWrite Operations Cannot Write an Empty list or Parse an empty string!")
    } else if (typeof(newData)==='string' ){
        if (!fs.existsSync(newData)) throw new Err("file does not exist");
        newData = JSON.parse(fs.readFileSync(newData))
    } 
    
    const client = new MongoClient(process.env.MONGO_CONN_URL)
    await client.connect();
    console.log('Connected successfully to server')
    const db = client.db(dbName)
    const collection = db.collection(collectionName);
    var projection = {}
    projection[id] = 1
    var filters = {}
    filters[id] = {"$exists": true}
    let cursor = collection.find({...filters}, {'project': {...projection}})
    const results = await cursor.toArray()
    const currentSet = new Set(results.map((d)=> d[id]))
    newData = newData.filter((d)=> !currentSet.has(d[id]))
    if (newData.length===0 && !mock){
        console.log('no new data to enter')
    } else if (!mock){
        let ct = await collection.insertMany(newData)
        console.log('inserted ', ct.insertedCount, ' into ', collectionName)
    } else {
        console.log("wouldve inserted ", newData.length , " into ", collectionName)
    }
    client.close()
    return results
}

async function queryDB(id="imageUrl2", collectionName, dbName='new'){
    const client = new MongoClient(process.env.MONGO_CONN_URL);
    await client.connect();
    console.log("Connected to server....");
    const db = client.db(dbName);
    const collection = db.collection(collectionName);
    var filter;
    typeof id === "string" ? filter[id] = {$exists: true} : filter = id; 
    var results = collection.find(filter, {limit: 5});
    results = await results.toArray();
    console.log(results);
    client.close(); 
}

async function createDBStats(dbName='new'){
	const client = new MongoClient(process.env.MONGO_CONN_URL);
	await client.connect();
	console.log('Connected successfully to Server');
	const db = client.db(dbName)
	var stats = await db.stats()
	stats.collectionStats = [];
    var collections = db.listCollections({}, {nameOnly: true})
    for await (let col of collections){
        let stat = await db.collection(col.name).stats()
        stats.collectionStats.push((({ns, size, count, avgObjSize, storageSize, freeStorageSize, capped, nindexes, indexBuilds,
        totalIndexSize, totalSize, indexSizes, scaleFactor, ok})=> ({ns, size, count, avgObjSize, storageSize, freeStorageSize, capped, nindexes, indexBuilds,
            totalIndexSize, totalSize, indexSizes, scaleFactor, ok}))(stat))
    }
    await client.close()
    await fs.promises.writeFile("/app/tmp/stats.json", JSON.stringify(stats, null, 4))
    console.log('stats updated')
	return null
}

function processInstacartItems({ target, defaultLocation=null, uuid }){
    !target.endsWith("/") ? target+="/" : 0; 
    let storeRegex = /publix|aldi|kroger|dollargeneral|familydollar|fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    let allItems = []
    let allItemAttributes = []
    let allCollections = []
    let fullPrices = []
    let fullInventories = []
    let fullCollectionItemIds = []
    let files = fs.readdirSync(target, {encoding: 'utf8', withFileTypes: true})
    files = files.filter((d)=> d.isFile())
    for (let file of files){
        console.log(file.name)
        file.name.slice(-9, -5) === "aldi" ? defaultLocation="23170": defaultLocation;
        data = fs.readFileSync(target+file.name, {encoding: 'utf8'})
        data = JSON.parse(data)
        let collections = data.filter((d)=>d.url.includes('CollectionProducts'))
        let items = data.filter((d)=>d.url.includes('operationName=Items'))
        let itemAttributes = data.filter((d)=>d.url.includes('item_attributes'))
        let locationId = defaultLocation 
        console.log('collections.length', collections.length)
        console.log('items.length', items.length)
        console.log('item_attributes.length', itemAttributes.length)
        itemAttributes.map((d)=>{
            d.view.map((v)=>{
                fullPrices.push({
                    'utcTimestamp': new Date(d.acquisition_timestamp),
                    'item_id': v.trackingParams.item_id,
                    'quantity': 1,
                    'value': parseFloat(v.pricing.price.replace('$', '')),
                    'locationId': locationId,
                    'isPurchase': false
                });
                v.pricing.promotionEndsAt ? fullPrices.slice(-1)[0].expirationDate = new Date(v.pricing.promotionEndsAt) : v;
                allItemAttributes.push(cleanup(v))
            })
        })

        if (items.length > 0){
            items.map((d)=> {
                d.data.items.map((di)=>{
                    fullInventories.push({
                        'utcTimestamp': new Date(d.acquisition_timestamp),
                        'item_id': di.viewSection.trackingProperties.item_id,
                        'stockLevel': di.viewSection.trackingProperties.stock_level,
                        'locationId': locationId,
                        'availability_score': di.viewSection.trackingProperties.availability_score
                    })
                })
                allItems = allItems.concat(cleanup(d.data.items))
            })
        }
        if (collections.length > 0){
            collections.map((d)=>{
                d.data.collectionProducts.items.map((di)=>{
                    fullInventories.push({
                        'utcTimestamp': new Date(d.acquisition_timestamp),
                        'item_id': di.viewSection.trackingProperties.item_id,
                        'stockLevel': di.viewSection.trackingProperties.stock_level,
                        'locationId': locationId,
                        'availability_score': di.viewSection.trackingProperties.availability_score
                    })
                })
                fullCollectionItemIds = fullCollectionItemIds.concat(d.data.collectionProducts.itemIds)
                allItems = allItems.concat(cleanup(d.data.collectionProducts.items))
                let collections_entry = cleanup(d.data.collectionProducts.collection)
                collections_entry.itemIds = d.data.collectionProducts.itemIds;
                allCollections.push(collections_entry)
            })
        }
    }
    var toCollectionItems = []
    var uniqueItems = new Set()
    allItems.map((d)=> {
        if (!uniqueItems.has(d.id)){
            toCollectionItems.push({
                id: d.id,
                productId: d.productId,
                legacyId: d.legacyId,
                legacyV3Id: d.legacyV3Id,
                description: d.name,
                customerFacingSize: d.size,
                soldBy: d.quantityAttributes.viewSection.unitAriaString,
                images: [{url: d.viewSection.itemImage.url, perspective: 'front', main: true}],
            })
            d.tags ? toCollectionItems.slice(-1)[0].isStoreBrand = true : d;
            d.dietary ? 'attributeSections' in d.dietary.viewSection ? toCollectionItems.slice(-1)[0].dietary = d.dietary.viewSection.attributeSections.map((x)=>x.attributeString):  toCollectionItems.slice(-1)[0].dietary = d.dietary.viewSection.attributeString:  d;
            uniqueItems.add(d.id)
        }
    })


    allItemAttributes.map((d)=>{
        let matches = toCollectionItems.filter((y)=>y.legacyV3Id===d.itemId)
        if (matches.length>0){
            matches = matches[0]
            matches.pricingUnit ? matches.pricingUnit = d.pricing.pricingUnit : d;
            matches.productType = d.pricing.productType
            matches.priceAffix ? matches.priceAffix = d.pricing.priceAffix : d;
        }    
    })
    console.log(toCollectionItems.length, fullPrices.length, fullInventories.length)
    
    insertFilteredData(uuid, "items", toCollectionItems)
    insertData(fullPrices, 'prices')
    insertData(fullInventories, 'inventories')

    return null

}

function processFoodDepotItems({target}){
    /**
     * Decomposes Data Collected on Food Depot's 1st Party Site and Transforms them Into Parsed MongoDB Documents for Items & Prices Collections  
     */
    target.endsWith('/') ? target : target+="/";
    let files = fs.readdirSync(target, {encoding: 'utf-8', withFileTypes: true})
    files = files.filter((d)=>d.isFile())
    var storeRegex = /fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    targetHeirarchy.endsWith("/") ? targetHeirarchy : targetHeirarchy+="/"; 
    var totalData = []
    var allPrices = []
    var allItems = []
    var itemIdSet = new Set()
    itemAttributes = new Set(['categories', 'Id', 'ProductCatalogueId', 'images', 'sellBy', 'orderBy', 'description', 'nutrition', 'brand', 'taxGroupCode'])
    for (let file of files){
        console.log(file.name)
        data = fs.readFileSync(target+file.name, {encoding: 'utf8'})
        data = JSON.parse(data)
        totalData = totalData.concat(data)
        let items = data.filter((d)=>d.url.includes('products?'))
        for (let itemSet of items){
            let utcTimestamp = new Date(itemSet.acquisition_timestamp);
            let url = itemSet.url
            let path = url.split('/')
            let locationId = path[path.indexOf('stores')+1]
            itemSet = itemSet.Result.Products.map((d)=>cleanup(d))
            itemSet.map((item)=>{
                item.PriceSaving===0 ? allPrices.push({
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.Price*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: item.PriceType 
                }) : allPrices.push({
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.Price*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: item.PriceType
                }, {
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.PriceRegular*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: 'Regular'
                });
                if ('WeightPerUnit' in item){
                    allPrices.push({
                        isPurchase: false,
                        utcTimestamp: utcTimestamp,
                        value: Math.floor(item.UnitPrice*1.1*100)/100,
                        quantity: item.WeightPerUnit,
                        id: item.Id,
                        locationId: locationId,
                        type: 'Average'
                    })
                }

                item.categories = []
                item.Categories.map((d)=>{
                    if ('ParentCategoryId' in d){
                        item.categories.push({name: d.Name, id: d.Id})
                    } else {
                        item.categories.push({name: d.Name, id: d.Id})
                    }
                })
                item.images = [{url: item.ImageUrl, perspective: 'front', main: true, size: "medium"}]  
                delete item.ImageUrl
                item.desciption = item.Name;
                delete item.Name;
                if (item.IsSoldByWeight){
                    item.sellBy = 'WEIGHT'
                    item.orderBy = 'WEIGHT'    
                } else {
                    item.sellBy = 'UNIT'
                    item.orderBy = "UNIT"
                }
                
                if (item.Tags){
                    for (let tag of item.Tags){
                        if (tag.Name==='Brand'){
                            let brand = tag.Value.toLowerCase().trim().split(' ')
                            .map((word)=> {return word.charAt(0).toUpperCase() + word.slice(1)}).join(' ');
                            item.brand = brand
                        } else if (tag.Value==="Y") {
                            let nutritionalCategory = tag.Name.replace(' ', '')
                            item.nutrition===undefined ? item.nutrition = {} : 1; 
                            item.nutrition[nutritionalCategory] = true
                        }
                    }
                }

                item.taxGroupCode = item.TaxRate
                let itemDoc = {}
                Object.keys(item).filter((d)=>itemAttributes.has(d)).map((d)=> itemDoc[d]=item[d])
                if (!itemIdSet.has(itemDoc.Id)){
                    allItems.push(itemDoc)
                    itemIdSet.add(itemDoc.Id)
                }
                
            })
        }
    }
    insertFilteredData("Id", 'items', allItems)
    insertData(allPrices, 'prices')

    return null
}

function processInternalCoupons({target, parser, uuid}){
    /**
     * Decomposes FamilyDollar, FoodDepot, and Publix 1st Party Promotions Through a Custom, User-Provided Parser and Inserts It into the DB
    */
    if (!parser){
        throw new Error('You Must Pass in a Parser to Parse!');
    }
    !target.endsWith("/") ? target+="/" : 0 ; 
    let files = fs.readdirSync(target, {encoding: 'utf-8', withFileTypes: true})
    files = files.filter((d)=>d.isFile())
    allCoupons = []
    let storesRegex = /fooddepot|publix|familydollar/
    var parserKeys = Object.keys(parser)
    let targetHeirarchy = target.match(storesRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    targetHeirarchy.endsWith("/") ? targetHeirarchy : targetHeirarchy+="/"; 
    for (let file of files){
        console.log(target+file.name, files.length)
        data = fs.readFileSync(target+file.name, {encoding: 'utf-8'})
        let chunk = JSON.parse(data)
        if (!Array.isArray(chunk)){
            chunk = [chunk]
        }
        chunk = chunk.filter((d)=> d.url.includes('savings') || d.url.includes('coupons') || d.url.includes('offers'))
        chunk.map((d)=> cleanup(d))
        if (target.includes('fooddepot')){
            chunk = chunk.filter((d)=>d.url.includes('appcard'))
            chunk = chunk.map((d)=>{return d.offers})
            chunk = chunk.flat()
        } else if (target.includes('publix')){
            chunk = chunk.map((c)=>{return c.Savings}).flat()
        } else {
            chunk = chunk.map((c)=>c.data).flat()
        }
        console.log("chunk length = ", chunk.length)
        chunk.map((d)=> {
            let newPromo = {}
            let relKeys = parserKeys.filter((pk)=> pk in d)
            for (let key of relKeys){
                let actions = parser[key]
                actions.convert ? d[key] = actions.convert(d[key]) : 0;
                actions.to ? actions.to in newPromo ? newPromo[actions.to] = [newPromo[actions.to], ...d[key]]: newPromo[actions.to] = d[key] : 0;
                actions.keep ? newPromo[key] = d[key] : 0;
            }
            allCoupons.push(newPromo)
        })
    }

    insertFilteredData(uuid, 'promotions', allCoupons, "new", false)

    return null
}

/**
 * prices 
    * {minimum_quantity, price, upc || id , {locationId, isPurchase, value}}
    * d.minimum_quantity !== d.casepack ?
    * {casepack, price, upc || id , {locationId, isPurchase, value}},
    * d.sale_price && d.sale_price !== "0.00" ?
    * *again if minimum quantity is not the same then add casepack
    * {casepack, price, upc || id , {locationId, isPurchase, value}}
 * 
{
    --inventory--
    "product.creationDate", => TODO
    "sku.availabilityStatus", => TODO
    "product.creationDate" => TODO

    -- prices --
    "product.clearance"
    "product." 

    -- product individual features--
    [x] "product.repositoryId", => "id"
    [o] "product.displayName", => "desciption"
    [x] "product.longDescription", => "romanceDescription"
    -- quantity for minimumOrder and allPrices -- 
    [x] "product.minimumQuantity", => minimumOrderQuantity
    "DollarProductType.casePackSize", => TODO caseSize
    "product.splitCaseAvailable" => TODO

    -- product categories -- 
    [x] "parentCategory.displayName", => TODO "categories" / "taxonomies"  STRING
    [x] "product.brand", => "brand" STRING
    [x] "product.category", TODO "categories" / "taxonomies" STRING
    [x] "product.smsb_pet", // delete 'No' string TODO "categories" / "taxonomies" 
    [x] "product.collection", TODO "categories" / "taxonomies" 
    [x] "product.x_collectionBase",

    -- product.web -- 
    [x] "product.primaryFullImageURL", ==> TODO "images" {url: "http://www.familydollar.com" + this, perspective: "front", main: true, size: "large"}

    -- product.link -- 
    [x] "product.route", // url + familydollar.com => TODO 'link'
    
    -- product.booleans -- 
    [x]"product.BPAFree", => bpa_free
    [x]"DollarProductType.madeInUSA", made_in_usa
    [x]"product.microwaveSafe", => microwave_safe
    [x]"product.dishwasherSafe", => dishwasher_safe
    [x]"product.foodSafe", => food_safe
    [x]"product.smsb_dryCleanOnly_string", => dry_clean_only
    [x]"product.smsb_combustible_string", => combustible
    [x]"product.smsb_flammable_string", => flammable
    [x]"product.smsb_flavor", => "flavor"
    [x]"product.scent", => "scent"
    [x]"product.smsb_wineType", => "wine_type"
    [x]"product.smsb_wineVarietal", => "wine_varietal"
    [x]"product.smsb_beveragePackSize", => "packSize"
    -- modalities --
    DollarProductType.callCenterOnly
    product.smsb_availableInStoreOnly

    
    
    
 } 
 */

function processFamilyDollarItems({target, defaultLocation="2394"}){
    // need new for family dollar items => prices, items, promotions<-items
    !target.endsWith("/") ? target+="/" : 0 ; 
    let storeRegex = /publix|aldi|kroger|dollargeneral|familydollar|fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    var allItems = []
    var allPrices = []
    
    
    var newParser = {
        combustible: {keep: true}, 
        made_in_usa: {keep: true},
        flammable: {keep: true},
        microwave_safe: {keep: true},
        bpa_free: {keep: true},
        dry_clean_only: {keep:true},
        dishwasher_safe: {keep: true},
        travel_size: {keep: true},
        food_safe: {keep: true},
        scent: {keep: true},
        flavor: {keep: true},
        wine_type: {keep:true},
        wine_varietal: {keep: true},
        id: {keep: true},
        description: {to: "romanceDescription", convert: function(x){return `<p>${x}</p>`}},
        minimum_quantity: {to: "minimumOrderQuantity"},
        categories: {to: "taxonomies", convert: function(x){
            let cats = x[0]
            let cparse = {"2": "department", "3": "commodity", "4": "subCommodity"}
            Object.keys(cats).map((k)=> {
            if (Object.keys(cparse).includes(k)){
                cats[cparse[k]] = cats[k]
                delete cats[k];
            } else {
                delete cats[k];
            }})
            return cats;
        }},
        UPCS: {to: "upc"},
        canonical: {to: "link"}
    };
    let newParser2 = {
        // simple rename
        "product.smsb_combustible_string": {"to": "combustible"},
        "DollarProductType.madeInUSA": {"to":"made_in_usa"},
        "product.smsb_flammable_string": {"to": "flammable"},
        "product.microwaveSafe": {"to": "microwave_safe"},
        "product.BPAFree": {"to": "bpa_free"},
        "product.dishwasherSafe": {"to": "dishwasher_safe"},
        "product.foodSafe": {"to": "food_safe"},
        "product.scent": {"to":"scent"},
        "product.smsb_flavor": {"to":"flavor"},
        "product.smsb_wineType": {"to":"wine_type"},
        "product.smsb_wineVarietal": {"to":"wine_varietal"},
        "product.smsb_dryCleanOnly_string": {"to":"dry_clean_only"},
        "product.smsb_flavor" : {to: "flavor"},
        "product.scent" : {to: "scent"},
        "product.smsb_wineType": {to: "wine_type"},
        "product.smsb_wineVarietal": {to: "wine_varietal"},
        "product.smsb_beveragePackSize": {to: "packSize"},
        "product.displayName": {to: "description", convert: (x)=> {
            x = x.replace("?", "")
            let customerFacingSize = x.split(",").slice(-1).filter((s)=>s.match(/\d+/g)!==null).map((match)=>{return match.trim()})
            x = x.split(",")[0]
            if (customerFacingSize.length>1){
                customerFacingSize= customerFacingSize.reverse().join(" / ")
            } else {
                customerFacingSize = customerFacingSize[0]
            }
            return {desciption: x, customerFacingSize: customerFacingSize}
        }},
        "DollarProductType.casePackSize": {to: "casePackSize"},


        // simple conversion exclusive to single feature
        "product.repositoryId": {to: "id", convert: (x)=> {
            if (typeof x !== 'string') x = String(x);
            return x.replace("FD", "")
        }},
        "product.longDescription": {to: "romanceDescription", convert: function(x){return `<p>${x}</p>`}},
        "product.minimumQuantity": {to: "minimumOrderQuantity"},
        "product.route": {to: "link", convert: function (x){return "https://www.familydollar.com" + x}},
        "product.primaryFullImageURL": {to: "images", convert: function (x){
            x = "https://www.familydollar.com" + x
            return [{main: true, perspective: 'front', url: x, size: "xlarge"}]
        }},
        "product.brand": {to: "brand", convert: (brand)=>{
            let brands; 
            if (!Array.isArray(brand)){
                brands = [brand];
            } else {
                brands = brand.filter((b)=>b.match(/^(llc|inc|ltd)(\.)?(\&[A-z]+\;)?$/gi))
            }
            return brands.map((brand)=>{return{name:  brand.replaceAll(/(&.+;|\([A-Z]+\))/g, '')}})

        }},
        "product.weightDimension": {to: "weight"},
        "_categories": {convert: function(wholeItem, filterVars=[
            "parentCategory.displayName", 
            "product.category",
            "product.brand",
            "product.smsb_petBase", 
            "product.collection",
            "product.x_collectionBase",
        ]){
            let returnValues = []
            Object.keys(wholeItem).map((key)=>{
                if (filterVars.includes(key)){
                    if (Array.isArray(wholeItem[key])){
                        returnValues = returnValues.concat(wholeItem[key].map((c)=>c.replaceAll(/(&.+;|\([A-Z]+\))/g, '')).filter((c)=>c && c!== 'Non-Navigable FD Collection' && c!=='Default Collection For Products'))
                    } else {
                        returnValues.push(wholeItem[key].replaceAll(/(&.+;|\([A-Z]+\))/g, ''))
                    }
                }
            })
            return Array.from(new Set(returnValues));
        }},
        "_nutrition": {convert: function(wholeItem, filterVars={
            "product.smsb_containsWheat_string": "WheatFree",
            "product.smsb_containsSoy_string": "SoyFree",
            "product.smsb_containsDairy_string": "DairyFree",
            "product.smsb_containsNuts_string" : "NutsFree",
            "product.smsb_containsEggs_string": "EggsFree",
            "product.sugarFree": "SugarFree",
            "product.glutenFree": "GlutenFree",
        }){
            let returnValues = {}
            let nutritionalCategories = Object.keys(filterVars)
            Object.keys(wholeItem).map((key)=>{
                if (nutritionalCategories.includes(key)){
                    if (key.includes("Free")){
                        returnValues[filterVars[key]] = wholeItem[key]
                    } else if (key.startsWith("contains")){
                        returnValues[filterVars[key]] = !wholeItem[key]
                    }
                }
            })
            return returnValues;
        }},
        "_dimensions": {convert: (wholeItem, filterVars=[
            "product.widthDimension",
            "product.depthDimension",
            "product.heightDimension",
            "product.lengthDimension",
        ])=> {
            let returnValues = {};
            for (filterVar of filterVars){
                returnValues[filterVar.split(".")[1].replace("Dimension", "")] = wholeItem[filterVar]
            }
            return returnValues
        }},
        "_modalities": {convert: (wholeItem, filterVars=[
            "product.smsb_availableInStoreOnly",
            "DollarProductType.callCenterOnly"
        ])=> {
            if (wholeItem[filterVars[0]]) {
                return ["IN_STORE"]
            } else if (wholeItem[filterVars[1]]){
                return ["CALL_CENTER"]
            } else {
                return ["SHIP", "IN_STORE"]
            }
        }},
        "_ratings": {convert : (wholeItem, filterVars=[
            "DollarProductType.numberOfReviews",
            "DollarProductType.averageRating"
        ])=>{
            return {ct: wholeItem[filterVars[0]], avg: wholeItem[filterVars[1]]}
        }},
        "*inventories": {convert: (wholeItem)=> {
            let fdId = typeof wholeItem["product.id"] === 'string' ? wholeItem["product.id"].replace("FD", "") : String(wholeItem["product.id"]); 
            let itemStatus = wholeItem["sku.availabilityStatus"]; 
            itemStatus = itemStatus == "INSTOCK" ? "IN_STOCK" : "OUT_OF_STOCK"; 
            return {"stockLevel": itemStatus, "locationId": defaultLocation,
            "utcTimestamp": new Date(wholeItem.utcTimestamp), "id": fdId}
        }},
        "*prices": {convert: (wholeItem)=> {
            let fdId = typeof wholeItem["product.id"] === 'string' ? wholeItem["product.id"].replace("FD", "") : String(wholeItem["product.id"]); 
            let productPrices = []
            productPrices.push({
                "quantity": +wholeItem["product.minimumQuantity"], // ["product.minimumQuantity"]
                locationId: defaultLocation, // "searchEventSummary.context.siteId" || defaultLocation
                isPurchase: false,
                utcTimestamp: new Date(wholeItem.utcTimestamp), // "acquisition_timestamp"
                value: +wholeItem["product.listPrice"], // "product.listPrice"
                id: fdId
            })
            if (wholeItem['product.splitCaseAvailable'] && wholeItem["product.minimumQuantity"] != wholeItem["DollarProductType.casePackSize"]){
                productPrices.push({
                    "quantity": +wholeItem["DollarProductType.casePackSize"], // product.casePackSize
                    locationId: defaultLocation, 
                    isPurchase: false,
                    utcTimestamp: new Date(wholeItem.utcTimestamp), 
                    value: +wholeItem["product.listPrice"] ,// product.x_unitprice
                    id: fdId

                })

            }
    
            if ("product.salePrice" in wholeItem){ // product.salePrice
                productPrices.push({
                    "quantity": +wholeItem["product.minimumQuantity"],
                    locationId: defaultLocation, 
                    isPurchase: false,
                    utcTimestamp: new Date(wholeItem.utcTimestamp), 
                    value: +wholeItem["product.SalePrice"], // product.SalePrice
                    type: wholeItem["product.clearance"] ? "Clearance" : "Sale",
                    id: fdId
                })

                if (wholeItem["product.minimumQuantity"] != wholeItem["DollarProductType.casePackSize"]){
                    productPrices.push({
                        "quantity": +wholeItem["DollarProductType.casePackSize"],
                        locationId: defaultLocation, 
                        isPurchase: false,
                        utcTimestamp: new Date(wholeItem.utcTimestamp), 
                        value: +wholeItem["product.SalePrice"], // product.salePrice
                        id: fdId
                    })                    
                }
            }
            return productPrices
        }}
        
        

    };


    fs.readdirSync(target).map((file) => {
        let data = JSON.parse(fs.readFileSync(target+file)).map((x)=>cleanup(x));        
        data=data.filter((d)=>"records" in d || "_auditInfo" in d)
        allItems = [], allPrices = [], allInventories = [], isOrignalItems = false;;

        data.map((z)=> {
            if ('records' in z){
                isOrignalItems = true
                let unwindRecords = z.records.map((record)=>{
                    record.utcTimestamp = z.acquisition_timestamp
                    let allMeta = record.allMeta
                    if ("badges" in allMeta){
                        let badges = allMeta.badges[0]
                        allMeta = {...allMeta, ...badges}
                    }
                    delete record["allMeta"]
                    let vv = allMeta['visualVariant'][0]['nonvisualVariant'][0]
                    delete allMeta['visualVariant'];
                    let attr = allMeta['attributes'][0]
                    delete allMeta['attributes']
                    record = {...allMeta, ...vv, ...attr, ...record}
                    Object.entries(record).map(([k, v])=> {if (v==="Y"){record[k]=true} else if (v==="N") {record[k]=false}})
                    return record
                }).filter((d)=>"minimum_quantity" in d);
                allItems = allItems.concat(unwindRecords)
                console.log("allItems ", allItems.length)
            } else if ('_auditInfo' in z){
                let unwindRecords = z.resultsList.records.map((rec)=>{
                        let attr = rec.attributes;
                        let records = rec.records[0].attributes;
                        let unwindRecord = {...attr, ...records, "utcTimestamp": z.acquisition_timestamp}
                        Object.entries(unwindRecord).map(([k, v])=>{
                            if (v.length === 1){
                                let unwoundValue = v[0]
                                if (unwoundValue.match(/^[0-9\.\$]+$/)){
                                    unwoundValue = +unwoundValue.replaceAll("$", "")
                                } else if (unwoundValue.match(/^(Y|N)$/)){
                                    unwoundValue = unwoundValue === "Y"
                                };
                                unwindRecord[k] = unwoundValue
                            }
                        })
                        return unwindRecord

                }).flat();
                allItems = allItems.concat(unwindRecords)
                console.log("allItems ", allItems.length)
            }
            
        })
        
        // allItems= allItems.concat(data.map((e)=>e.records).flat())
        allItems=allItems.filter((d)=>d)
        console.log(`parsed ${file}. ${allItems.length}`)
        if (isOrignalItems){
            allItems.map((d)=>{
                // minimumQuantity, Case, Sale if Exists
                allPrices.push({
                    "quantity": d.minimum_quantity, // ["product.minimumQuantity", "DollarProductType.x_minimumQuantityNumber"]
                    locationId: defaultLocation, // "searchEventSummary.context.siteId"
                    isPurchase: false,
                    utcTimestamp: new Date(d.utcTimestamp), // "acquisition_timestamp"
                    value: d.price // "product.listPrice"
                })
                d.upc ? 
                    allPrices.slice(-1)[0]['upc'] = d.upc :
                    allPrices.slice(-1)[0]['id'] = d.id // product.id minus FD
                ;
                // for Case
                if (d.minimum_quantity != d.casepack){
                    //  "product.minimumQuantity" != product.casePackSize
                    allPrices.push({
                        "quantity": +d.casepack, // product.casePackSize
                        locationId: defaultLocation, 
                        isPurchase: false,
                        utcTimestamp: new Date(d.utcTimestamp), 
                        value: d.price // product.x_unitprice
                    })
                    d.upc ? 
                    allPrices.slice(-1)[0]['upc'] = d.upc :
                    allPrices.slice(-1)[0]['id'] = d.id // product.id minus FD
                    ;
                }
        
                if (d.sale_price && d.sale_price!=="0.00"){ // product.salePrice
                    allPrices.push({
                        "quantity": d.minimum_quantity,
                        locationId: defaultLocation, 
                        isPurchase: false,
                        utcTimestamp: new Date(d.utcTimestamp), 
                        value: d.sale_price // product.SalePrice
                    })
                    d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
                    d.promo_price ? allPrices.slice(-1)[0]['type'] = d.promo_price : null ; // product.x_deals
        
                    if (d.minimum_quantity!=d.casepack){
                        allPrices.push({
                            "quantity": +d.casepack,
                            locationId: defaultLocation, 
                            isPurchase: false,
                            utcTimestamp: new Date(d.utcTimestamp), 
                            value: d.sale_price // product.salePrice
                        })
                        d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
                        d.promo_price ? allPrices.slice(-1)[0]['type'] = d.promo_price : null ; 
                    }
                    
                }
            })
            
            allItems.map((x)=> {
                Object.keys(x).map((nk)=>{
                    if (nk.startsWith("contains") || nk.startsWith("sugar") || nk.startsWith("gluten")){
                        //nk.endsWith("free") ? nk=nk.slice(0, -1): nk;
                        let nutObj = {}
                        if (nk.endsWith("free")){
                            let newKey = nk.split("_").map((str)=> str[0].toUpperCase() +str.slice(1))
                            nutObj[newKey] = x[nk]
                        } else if (nk.startsWith("contains")){
                            let newKey = nk.split("_").slice(-1).map((str)=> str[0].toUpperCase() +str.slice(1) + "Free").join("")
                            nutObj[newKey] = !x[nk]
                        }
                        "nutrition" in x ? x["nutrition"] = {...x["nutrition"], ...nutObj}: x["nutrition"] = nutObj;
                        delete x[nk]; 
                    } else if (nk.startsWith("weight")){
                        x["weight"] = x[nk]
                        delete x[nk];
                    } else if (nk.endsWith("Dimension")){ 
                        let dimObj = {}
                        dimObj[nk.replace("Dimension", "")] = x[nk]
                        "dimensions" in x ? x["dimensions"] = {...x.dimensions, ...dimObj} : x["dimensions"] = dimObj;
                        delete x[nk];
                    } else if (nk === "available_in_store_only" && x[nk]){
                        x["modalities"] = ["IN_STORE"]
                        delete x[nk];
                    } else if (nk === "call_center_only" && x[nk]){
                        x["modalities"] = ["CALL_CENTER"]
                        delete x[nk];
                    } else if (nk==="brand"){
                        brands = x[nk]
                        x[nk] = brands.map((brand)=>{return{name:  brand.replaceAll(/&.+;/g, '')}})
                    } else if (nk==="num_reviews" && x[nk]){
                        x["ratings"] = {ct: x[nk], avg: x["average_rating"]}
                        delete x[nk];
                        delete x["average_rating"]
                    } else if (nk==="name"){
                        let name = x[nk]
                        name = name.replace("?", "")
                        let customerFacingSize = name.split(",").slice(1).filter((s)=>s.match(/\d+/g)!==null).map((match)=>{return match.trim()})
                        x[nk] = name.split(",")[0]
                        if (!customerFacingSize===""){
                            x["customerFacingSize"] = customerFacingSize.reverse().join(" / ")
                        }
                        x["description"] = x[nk]
                        delete x[nk];
                        
                    } else if (Object.keys(newParser).includes(nk)){
                        let actions = newParser[nk]
                        if (newParser[nk].convert){
                            x[nk] = actions.convert(x[nk])
                        }
                        if (actions.to){
                            x[actions.to] = x[nk];
                        }
                        if (actions.keep===undefined){
                            delete x[nk]
                        }
        
                    } else {
                        delete x[nk]
                    }
                    
                })
            })
            let idSet = new Set()
            allItems = allItems.filter((i)=>{
                if (idSet.has(i.id)){
                    return false;
                } else {
                    idSet.add(i.id)
                    return true
                }
            })
            console.log(allItems[0])
            console.log(allPrices[0])
        } else {
            allItems = allItems.map((x)=> {
                let returnItem = {};
                for (let key of Object.keys(newParser2)){
                    let actions = newParser2[key]
                    if (actions.convert && key.startsWith("_")){
                        returnItem[key.slice(1)] = actions.convert(x)
                    } else if (actions.convert && key === "*prices"){
                        allPrices = allPrices.concat(actions.convert(x))
                    } else if (actions.convert && key === "*inventories"){
                        allInventories = allInventories.concat(actions.convert(x))
                    } else if (key === 'product.displayName' && key in x) {
                        let obj = actions.convert(x[key]);
                        returnItem = {...returnItem, ...obj}
                    } else if (actions.convert && actions.to && key in x){
                        returnItem[actions.to] = actions.convert(x[key])
                    } else if (actions.to  && key in x){
                        returnItem[actions.to] = x[key]
                    }
                }
                return cleanup(returnItem)
            })

            let idSet = new Set()
            allItems = allItems.filter((i)=>{
                if (idSet.has(i.id)){
                    return false;
                } else {
                    idSet.add(i.id)
                    return true
                }
            })
            insertData(allPrices, "prices")
            insertData(allInventories, "inventories")
            insertFilteredData("id", "items", allItems)
            
        }
    })

    return null
}

function processDollarGeneralItems({target, couponParser, itemParser}){
    // Items from promotion scrapes currently: items => as defined below and prices and inventories
        // [description: String, upc: String, images: [{url: String | null, perspective: String, main: Boolean, size: String "xlarge" }]]
        // soldInStore: Boolean , IsBopisEligible: Boolean, modalities: Array = ["IN_STORE", "PICKUP", "SHIP"]
    let scrapedArray = new Array(); 
    if (!target.endsWith("/")) target+="/"; 
    let files = fs.readdirSync(target, {encoding: 'utf8', withFileTypes: true}).filter((d)=> d.isFile()).map((d)=> d.name);
    let targetHeirarchy = target.slice(target.indexOf("dollargeneral"))
    scrapedArray = files.map((d)=> JSON.parse(fs.readFileSync(target+d))).flat();

    var couponsForDB = [], items = [], prices=[], inventories=[], mapWithItemKeys={}, utcTimestamp, locationId, offerId;
    var itemsForDB = [];
    scrapedArray.sort((a, b) => {
        return a.url.includes("products") && !b.url.includes("products") ? -1 : 0; 
    })
    // separate coupons from items
    scrapedArray.filter((object)=> {
        if ("eligibleProductsResult" in object || 'categoriesResult' in object){
            // needs modalities, cleanup ratings
            items = object.eligibleProductsResult?.Items || object.categoriesResult?.ItemList.Items; 
            // products from coupon scrapes
            utcTimestamp = object.acquisition_timestamp;
            locationId = object.url.match(/(?:store|storeNumber)=(\d+)/)[1];
            if ("eligibleProductsResult" in object){
                offerId = object.url.match(/couponId=([^&]+)/);
            }
            // all items in list will belong to same location and offerId
            items.map((item)=> {
                item.UPC = String(item.UPC)
                item["modalities"] = itemParser["modalities"].create(item);
                if (offerId && offerId in mapWithItemKeys){
                    mapWithItemKeys[offerId].add(item.UPC)
                } else if (offerId) {
                    mapWithItemKeys[offerId] = new Set([item.UPC])
                 }
                let newItem = {};
                let relevantKeys = Object.keys(itemParser)
                for (key of relevantKeys){
                    let actions = itemParser[key]
                    if (key === "OfferID"){
                        item[key] = actions.convert(item[key], mapWithItemKeys)
                    } else if (key === "RatingReviewCount") {
                        item[key] = actions.convert(item[key], item["AverageRating"])
                    } else if (key === "_prices"){
                        prices = prices.concat(actions.convert(item, locationId, utcTimestamp))
                    } else if (key==="_inventories"){
                        inventories.push(actions.convert(item, locationId, utcTimestamp))
                    } else {
                        actions.convert && item[key]? item[key] = actions.convert(item[key]) : 0;
                    }
                
                    actions.to ? newItem[actions.to] = item[key] : 0;
                    actions.keep ? newItem[key] = item[key] : 0;
                    actions.bool && item[key] ? newItem[key] = item[key]: 0;
                };
                newItem = cleanup(newItem)
                itemsForDB.push(newItem)    

            })
        } else if ("Coupons" in object) {
            utcTimestamp = object.acquisition_timestamp;
            object.Coupons.map((coupon)=> {
                let newPromo = {};
                let relevantKeys = Object.keys(coupon).filter((c)=> c in couponParser)
                for (key of relevantKeys){
                    let actions = couponParser[key]
                    if (key === "OfferID"){
                        newPromo.id = coupon[key]
                        actions.convert ? coupon[key] = actions.convert(coupon[key], mapWithItemKeys) : 0;
                    } else if (key === "OfferDescription") {
                        actions.convert ? coupon[key] = actions.convert(coupon) : 0;
                    }
                    else {
                        actions.convert ? coupon[key] = actions.convert(coupon[key]) : 0;
                    }
                    
                    actions.to ? newPromo[actions.to] = coupon[key] : 0;
                    actions.keep ? newPromo[key] = coupon[key] : 0;
                    actions.bool && coupon[key] ? newPromo[actions.to] = coupon[key]: 0;
                };
                newPromo = cleanup(newPromo)
                couponsForDB.push(newPromo)    
            })

        }
    });
    //  will handle entering in items, prices, inventories from getDollarGeneralItems;
    // and handle entering in promotions, items, prices & inventories from getDollarGeneralCoupons;
    // promotions, items => insertFilteredData(id="id", collectionName="promotions", newData=this, dbName='new' )
    couponsForDB.length>0 ? insertFilteredData("id", "promotions", couponsForDB, "new", false): 0; 
    itemsForDB.length>0 ? insertFilteredData("upc", "items", itemsForDB, "new", false):0;
    prices.length>0 ? insertData(prices, "prices", false):0;
    inventories.length>0 ? insertData(inventories, "inventories", false):0;
    return;
}

const program = new Command(); 

program
    .name("grocery-transform")
    .description("Transform and Normalize Preprocessed Data Scraped from Containerized Browser")
    .version("1.0.0");

program
    .command("transform")
    .description("processes grocery data and inserts normalized data into MongoDB")
    .option("--aldi <procedure>", "transform and insert instacart data for Aldi Stores")
    .option("--family-dollar <procedure>", "transform and insert instacartItems, items & promotions data for Family Dollar Stores")
    .option("--kroger <procedure>", "transform and insert promotions and trips for Kroger Stores")
    .option("--publix <procedure>", "transform and insert promotions and items for Publix Stores")
    .option("--dollar-general <procedure>", "transform and insert promotions and items for Dollar General Stores")
    .option("--food-depot <procedure>", "transform and insert promotions and items for Food Depot Stores")
    .action((options)=> {
        let [transformTask] = Object.entries(options).map(([k, v])=>{return k+v[0].toUpperCase()+v.slice(1)});
        console.log(transformTask)
        var transformerVars = {
            "foodDepotPromotions": {func: processInternalCoupons, args: {
                uuid: "targetOfferId",
                parser: {
                    "saveValue": {to: "value", convert: function (x) {return Number(x/100)}},
                    "expireDate": {to: "endDate", convert: function (x) {return new Date(x)}},
                    "effectiveDate": {to: "startDate", convert: function (x) {return new Date(x)}},
                    "offerId": {keep: true},
                    "targetOfferId": {keep: true},
                    "category": {to: "categories", convert: function(x) {return [x]}},
                    "image": {to: "imageUrl", convert: function (x){return x.links.lg}},
                    "brand": {to: "brandName"},
                    "details": {to: "terms"},
                    "offerType": {to: "type" }
                },
                target: "/app/tmp/collections/fooddepot/promotions/"
            }}, // target, parser, uuid="targetOfferId"
            "publixPromotions": {func: processInternalCoupons, args: {
                uuid: "id",
                parser: {
                    "id": {keep: true},
                    "dcId": {keep: true},
                    "waId": {keep: true},
                    "savings": {to: "value", convert: function(x){let n =  Number(x.replaceAll(/.+\$/g, '')); if (isNaN(n)){n=x} return n}},
                    "description": {to: "shortDescription"},
                    "redemptionsPerTransaction" : {to: "redemptionsAllowed"},
                    "minimumPurchase": {to: "requirementQuantity"},
                    "categories": {keep: true},
                    "imageUrl": {keep: true},
                    "brand": {to: "brandName"},
                    "savingType": {to: "type"},
                    "dc_popularity": {to: "popularity"}
                },
                target: "/app/tmp/collections/publix/promotions/"
            }}, //target, parser, uuid="id"
            "familyDollarPromotions": {func: processInternalCoupons, args:{
                uuid: "id", 
                parser: {
                    "mdid": {to: "id"},
                    "brand": {to: "brandName"},
                    "offerType": {to: "type"},
                    "description": {to: "shortDescription"},
                    "terms": {keep: true},
                    "category": {to: "categories", convert: (x)=>{
                        return x.name
                    }},
                    "tags": {to: "categories", convert: (x)=> {
                        return x.map((d)=>d.replace(/fd-/, '').trim().split('-').map((d)=>d[0].toUpperCase()+d.slice(1).toLowerCase()).join('-')).flat()
                    }},
                    "redemptionStartDateTime": {to: 'startDate', convert: (x)=> new Date(x.iso)},
                    "expirationDateTime": {to: 'expirationDate', convert: (x)=> new Date(x.iso)},
                    "clipStartDateTime": {to: 'clipStartDate', convert: (x)=> new Date(x.iso)},
                    "clipEndDateTime": {to: 'clipEndDate', convert: (x)=> new Date(x.iso)},
                    "offerSortValue": {to: 'value', convert: (x)=>+x},
                    "minPurchase": {to: 'requirementQuantity', convert: (x)=>+x},
                    "redemptionsPerTransaction": {to: 'redemptionsAllowed'},
                    "imageUrl": {keep: true},
                    "enhancedImageUrl": {keep: true},
                    "type": {to: "isManufacturerCoupon", convert: (x)=>x==="mfg"? true:false},
                    "popularity": {keep: true},
                    "clippedCount": {keep: true}
                
                },
                target: "/app/tmp/collections/familydollar/promotions/"
            }}, // target, parser, uuid="id"
            "dollarGeneralPromotions": {func: processDollarGeneralItems, args: {
                target: "/app/tmp/collections/dollargeneral/promotions/",
                couponParser: {
                    OfferCode: {to: "offerCode"},
                    OfferGS1: {to: "offerGS1", bool: true},
                    OfferDescription: {to: "shortDescription", convert: (x)=> {
                        if (x.OfferSummary.match(/^save/i)){
                            if (x.OfferDescription.match(/^on[^e]/i)) x.OfferDescription = " " + x.OfferDescription;
                            else x.OfferDescription = " on " + x.OfferDescription;
                            return x.OfferSummary + x.OfferDescription
                        } else {
                            return x.OfferDescription 
                        }
                    }},
                    BrandName: {to: "brandName"},
                    CompanyName: {to: "companyName"},
                    OfferType: {to: "offerType"},
                    OfferDisclaimer: {to: "terms", bool: true},
                    IsManufacturerCoupon: {to: "isManufacturerCoupon"},
                    RewaredCategoryName: {to: "categories"},
                    OfferActivationDate: {to: "startDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    OfferExpirationDate: {to: "expirationDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    RewaredOfferValue: {to: "value"},
                    MinQuantity: {to: "requirementQuantity"},
                    RedemptionLimitQuantity: {to: "redemptionsAllowed"},
                    RecemptionFrequency: {to: "redemptionFreq"},
                    Image1: {to: "imageUrl"},
                    Image2: {to: "imageUrl2"},
                    OfferID: {to:"productUpcs", convert: (offerId, mapWithItemKeys) => {
                        return offerId in mapWithItemKeys ? Array.from(mapWithItemKeys[offerId]) : [];
                    }}
                },
                itemParser: {
                    UPC: {to: "upc"},
                    Description: {to: "description"},
                    Image: {to: "images", convert: (img)=> {
                        return [{url: img, perspective: 'front', main: true, size: "xlarge"}]
                    }},
                    IsSellable: {to: "soldInStore"}, 
                    IsBopisEligible: { keep: 1},
                    IsGenericBrand: {keep: 1},
                    modalities: {create: (item)=> {
                        let mParse = {"IsSellable": "IN_STORE", "isShipToHome": "SHIP", "isPopshelfShipToHome": "SHIP", "IsBopisEligible": "PICKUP"}
                        return Object.entries(item).map(([k, v])=> {return k in mParse && v? k : 0;}).filter((k)=>k).map((truthyKey)=> {return mParse[truthyKey]})
                    }, to: "modalities"},
                    RatingReviewCount: {bool: 0, to: "ratings", convert: (ratingCount, ratingAverage)=> {
                        if (ratingCount){
                            return {avg: ratingAverage, ct: ratingCount}
                        }
                    }},
                    Categories: {bool:true, convert: (x)=> {
                        return x.split("|")
                    }},
                    _prices: {convert: (full_item, locationId, utcTimestamp) => { 
                        let returnValues = [];
                        returnValues.push({"value": full_item.OriginalPrice, "type": "Regular", "isPurchase": false,
                        "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                        modalities: full_item.modalities });
                        if (full_item.OriginalPrice !== full_item.Price){
                            returnValues.push({"value": full_item.Price, "type": "Sale", "isPurchase": false,
                            "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                            modalities: full_item.modalities });
                        }
                        return returnValues;
                    }},
                    _inventories: {convert: (full_item, locationId, utcTimestamp)=> {
                        let itemStatus = full_item.InventoryStatus; 
                        itemStatus = itemStatus ==1? "TEMPORARILY_OUT_OF_STOCK" : itemStatus == 2 ? "LOW" : "HIGH"; 
                        return {"stockLevel": itemStatus, "availableToSell": full_item.AvailableStockStore, "locationId": locationId,
                        "utcTimestamp": new Date(utcTimestamp), "upc": full_item.UPC}
                    }}
                }
            }},
            "dollarGeneralItems": {func: processDollarGeneralItems, args: {
                target: "/app/tmp/collections/dollargeneral/items/",
                couponParser: {
                    OfferCode: {to: "offerCode"},
                    OfferGS1: {to: "offerGS1", bool: true},
                    OfferDescription: {to: "shortDescription", convert: (x)=> {
                        if (x.OfferSummary.match(/^save/i)){
                            if (x.OfferDescription.match(/^on[^e]/i)) x.OfferDescription = " " + x.OfferDescription;
                            else x.OfferDescription = " on " + x.OfferDescription;
                            return x.OfferSummary + x.OfferDescription
                        } else {
                            return x.OfferDescription 
                        }
                    }},
                    BrandName: {to: "brandName"},
                    CompanyName: {to: "companyName"},
                    OfferType: {to: "offerType"},
                    OfferDisclaimer: {to: "terms", bool: true},
                    IsManufacturerCoupon: {to: "isManufacturerCoupon"},
                    RewaredCategoryName: {to: "categories"},
                    OfferActivationDate: {to: "startDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    OfferExpirationDate: {to: "expirationDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    RewaredOfferValue: {to: "value"},
                    MinQuantity: {to: "requirementQuantity"},
                    RedemptionLimitQuantity: {to: "redemptionsAllowed"},
                    RecemptionFrequency: {to: "redemptionFreq"},
                    Image1: {to: "imageUrl"},
                    Image2: {to: "imageUrl2"},
                    OfferID: {to:"productUpcs", convert: (offerId, mapWithItemKeys) => {
                        return offerId in mapWithItemKeys ? Array.from(mapWithItemKeys[offerId]) : [];
                    }}
                },
                itemParser: {
                    UPC: {to: "upc"},
                    Description: {to: "description"},
                    Image: {to: "images", convert: (img)=> {
                        return [{url: img, perspective: 'front', main: true, size: "xlarge"}]
                    }},
                    IsSellable: {to: "soldInStore"}, 
                    IsBopisEligible: { keep: 1},
                    IsGenericBrand: {keep: 1},
                    modalities: {create: (item)=> {
                        let mParse = {"IsSellable": "IN_STORE", "isShipToHome": "SHIP", "isPopshelfShipToHome": "SHIP", "IsBopisEligible": "PICKUP"}
                        return Object.entries(item).map(([k, v])=> {return k in mParse && v? k : 0;}).filter((k)=>k).map((truthyKey)=> {return mParse[truthyKey]})
                    }, to: "modalities"},
                    RatingReviewCount: {bool: 0, to: "ratings", convert: (ratingCount, ratingAverage)=> {
                        if (ratingCount){
                            return {avg: ratingAverage, ct: ratingCount}
                        }
                    }},
                    Categories: {bool:true, convert: (x)=> {
                        return x.split("|")
                    }},
                    _prices: {convert: (full_item, locationId, utcTimestamp) => { 
                        let returnValues = [];
                        returnValues.push({"value": full_item.OriginalPrice, "type": "Regular", "isPurchase": false,
                        "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                        modalities: full_item.modalities });
                        if (full_item.OriginalPrice !== full_item.Price){
                            returnValues.push({"value": full_item.Price, "type": "Sale", "isPurchase": false,
                            "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                            modalities: full_item.modalities });
                        }
                        return returnValues;
                    }},
                    _inventories: {convert: (full_item, locationId, utcTimestamp)=> {
                        let itemStatus = full_item.InventoryStatus; 
                        itemStatus = itemStatus ==1? "TEMPORARILY_OUT_OF_STOCK" : itemStatus == 2 ? "LOW" : "HIGH"; 
                        return {"stockLevel": itemStatus, "availableToSell": full_item.AvailableStockStore, "locationId": locationId,
                        "utcTimestamp": new Date(utcTimestamp), "upc": full_item.UPC}
                    }}
                }
            }},
            "familyDollarItems": {func: processFamilyDollarItems, args: {
                defaultLocation: "2394",
                target: "/app/tmp/collections/familydollar/items/"
            }},
            "familyDollarInstacartItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "2394",
                target: "/app/tmp/collections/familydollar/instacartItems/"
            }},
            "foodDepotItems": {func: processFoodDepotItems, args: {
                target: "/app/tmp/collections/fooddepot/items/"
            }},
            "publixItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "121659",
                target: "/app/tmp/collections/publix/items/"
            }}, 
            "aldiItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "23170",
                target: "/app/tmp/collections/aldi/items/"
            }} 
        };
        // run proper taskformer task with proper preconfigured arguments
        transformerVars[transformTask].func(transformerVars[transformTask].args)
        return null
    });

program
    .command("compress")
    .description("compress full scraping datasets for archiving and/or other future purposes")
    .option("--path <path>", "path to archive")
    .option("--name <name>", "name to give gpg archive tar file")
    .action(async (options)=>{
        zipUp(options.path, options.name)
    })

program
    .command("peek")
    .description("Look at raw jsons generated by a website's api from gpg tar files and create summary files using json-summary")
    .option("--input <path>", "input api file")
    .option("--output <path>", "output summary file")
    .action(async (options)=>{
        const json = require("json-summary");
        // var data = fs.readFileSync(options.input); 
        // data = JSON.parse(data)
        // console.log(data.length)
        processFamilyDollarItems({target: options.input})
        // let baseItems = data.map((wholeQuery)=>
        //     {
        //     //console.log(wholeQuery.resultsList.records.length)
        //     return wholeQuery.resultsList.records.map((rec)=>{
        //             let attr = rec.attributes;
        //             let records = rec.records[0].attributes;
                    
        //             s = {...attr, ...records, "utcTimestamp": wholeQuery.acquisition_timestamp}
        //             Object.entries(s).map(([k, v])=>{
        //                 if (v.length === 1){
        //                     s[k] = v[0]
        //                 }
        //             })

        //             // for (let key of Object.keys(s)){
        //             //     if (!(key.toLowerCase().includes('price')) && key!=='product.clearance' && key!=="sku.onSale" && key!== "product.x_deals"&& key!=="product.splitCaseAvailable" && key!=='product.displayName'&& key!== "DollarProductType.splitCaseMultiple" &&  key!=='parentCategory.displayName' && key!=="DollarProductType.casePackSize" && key!=="product.minimumQuantity"){
        //             //         delete s[key]
        //             //     }
        //             // };
                    
        //         return s
        //         })
        // }).flat();
        // console.log(new Set (baseItems.map((d)=>d["sku.availabilityStatus"])))
        // //processFamilyDollarItems({target: "../../tmp/collections/familydollar/items/"})
        // let summary = json.summarize(baseItems);
        // summary = JSON.stringify(summary, null, 4);
        // fs.writeFileSync(options.output, summary)
        return null; 
    })

program
    .command("hash")
    .description("test hash values for old transforms so that it process legacy files the same")
    .option("--input <path>", "input api file")
    .action(async (options)=>{
        const crypto = require('crypto');
        const processFamilyDollarItems2 = require("./transform1.js");
        var data = fs.readFileSync(options.input); 
        data = JSON.parse(data)
        console.log(data.length)

        var secret = 'test'
        console.log(processFamilyDollarItems2)
        let originalTransform = processFamilyDollarItems2({target: "../tmp/collections/familydollar/items/"}).toString();
        let newTransform = processFamilyDollarItems({target: "../tmp/collections/familydollar/items/"} ).toString(); 
        
        let hash1 = crypto.createHmac('sha256', secret)
            .update(originalTransform)
            .digest('hex');
        let hash2 = crypto.createHmac('sha256', secret)
            .update(newTransform)
            .digest('hex');
        
        console.log(hash1, hash2, hash1 === hash2);
        return null; 
    })

program.parse();