require("dotenv").config()
const fs = require('fs')
const {MongoClient} = require('mongodb')
const { spawn } = require('child_process')
const { Command } = require("commander")

function cleanup(object){
    Object.entries(object).forEach(([k, v])=>{
        if (v && typeof v ==='object'){
            cleanup(v);
        }
        if (v && typeof v ==='object' && !Object.keys(v).length || v===null || v === undefined || v === '' || k === '__typename' || v === 'none' || (Object.keys(object).length===1 && typeof v === 'boolean' && !v)) {
            if (Array.isArray(object)) {
                object.splice(k, 1)
            } else if (!(v instanceof Date)) {
                delete object[k];
            }
        }
    })
    return object
}

function setEquivalent(setA, setB){
    return setA.size === setB.size && [...setA].every((x)=> setB.has(x))
}

const zipUp = (file) => {
    // zips and encrypts full body json documents generated by browser
    let ds = file || (new Date()).toLocaleDateString().replaceAll("/", "_")
    var tarCmd = spawn("tar", ["--remove-files", "-cvzf", "-", file])
    var gpgCmd = spawn("gpg", ["--output", `${ds}.tar.gz.gpg`, '--trust-model', 'always', '--encrypt', '--recipient', process.env.EMAIL])
    tarCmd.stdout.pipe(gpgCmd.stdin);
    tarCmd.stderr.on("data", (data)=> console.log(data.toString()))
    tarCmd.on("close", (code)=> {console.log('tar process exited with code ', code); gpgCmd.stdin.end()})
    gpgCmd.stderr.on("data", (data)=> console.log(data.toString()))
    gpgCmd.on("close", (code)=> {console.log('gpg process exited with code ', code);})

}

const decryptAndExtract = (file=undefined) => {
    let ds = file || (new Date).toLocaleDateString().replaceAll("/", "_")
    var gpgCmd = spawn("gpg", ["-d", `${ds}.tar.gz.gpg`])
    var tarCmd = spawn("tar", ["-xvzf", "-"])
    gpgCmd.stdout.pipe(tarCmd.stdin)
    gpgCmd.stderr.on("data", (data)=> console.log("gpgCmd stderr => ", data.toString()))
    gpgCmd.on("close", (code)=> {
        console.log('gpg process exited with code ', code);
        tarCmd.stdin.end(); 
    })
    tarCmd.stderr.on("data", (data)=> console.log("tarCmd stderr => ", data.toString()))
    tarCmd.on("close", (code)=> console.log("tar process exited with code ", code))
}

function insertData(listOfObjects, collectionName, mock=false){
    if (listOfObjects.length===0) {
        throw new Error("bulkWrite Operations Cannot Write an Empty list or Parse an empty string!")
    } else if (typeof(listOfObjects)==='string' ){
        if (!fs.existsSync(listOfObjects)) throw new Err("file does not exist");
        listOfObjects = JSON.parse(fs.readFileSync(listOfObjects))
    } 
    const client = new MongoClient(process.env.MONGO_CONN_URL)
    const dbName = 'new'

    async function main(){
        await client.connect();
        console.log('Connected successfully to server')
        const db = client.db(dbName)
        const collection = db.collection(collectionName);
        if (!mock){
            let cursor = await collection.insertMany(listOfObjects)
            console.log(`inserted ${cursor.insertedCount} into ${collectionName}`)
        } else {
            console.log("wouldve inserted ", listOfObjects.length, " into ", collectionName)
        }
        
        return 'done.'
    }

    main()
        .then(console.log)
        .catch(console.error)
        .finally(()=> client.close())
}

async function insertFilteredData(id, collectionName, newData = undefined, dbName = 'new', mock=false){
    if (newData.length===0) {
        throw new Error("bulkWrite Operations Cannot Write an Empty list or Parse an empty string!")
    } else if (typeof(newData)==='string' ){
        if (!fs.existsSync(newData)) throw new Err("file does not exist");
        newData = JSON.parse(fs.readFileSync(newData))
    } 
    
    const client = new MongoClient(process.env.MONGO_CONN_URL)
    await client.connect();
    console.log('Connected successfully to server')
    const db = client.db(dbName)
    const collection = db.collection(collectionName);
    var projection = {}
    projection[id] = 1
    var filters = {}
    filters[id] = {"$exists": true}
    let cursor = collection.find({...filters}, {'project': {...projection}})
    const results = await cursor.toArray()
    const currentSet = new Set(results.map((d)=> d[id]))
    newData = newData.filter((d)=> !currentSet.has(d[id]))
    if (newData.length===0 && !mock){
        console.log('no new data to enter')
    } else if (!mock){
        let ct = await collection.insertMany(newData)
        console.log('inserted ', ct.insertedCount, ' into ', collectionName)
    } else {
        console.log("wouldve inserted ", newData.length , " into ", collectionName)
    }
    client.close()
    return results
}

async function queryDB(id="imageUrl2", collectionName, dbName='new'){
    const client = new MongoClient(process.env.MONGO_CONN_URL);
    await client.connect();
    console.log("Connected to server....");
    const db = client.db(dbName);
    const collection = db.collection(collectionName);
    var filter;
    typeof id === "string" ? filter[id] = {$exists: true} : filter = id; 
    var results = collection.find(filter, {limit: 5});
    results = await results.toArray();
    console.log(results);
    client.close(); 
}

async function createDBStats(dbName='new'){
	const client = new MongoClient(process.env.MONGO_CONN_URL);
	await client.connect();
	console.log('Connected successfully to Server');
	const db = client.db(dbName)
	var stats = await db.stats()
	stats.collectionStats = [];
    var collections = db.listCollections({}, {nameOnly: true})
    for await (let col of collections){
        let stat = await db.collection(col.name).stats()
        stats.collectionStats.push((({ns, size, count, avgObjSize, storageSize, freeStorageSize, capped, nindexes, indexBuilds,
        totalIndexSize, totalSize, indexSizes, scaleFactor, ok})=> ({ns, size, count, avgObjSize, storageSize, freeStorageSize, capped, nindexes, indexBuilds,
            totalIndexSize, totalSize, indexSizes, scaleFactor, ok}))(stat))
    }
    await client.close()
    await fs.promises.writeFile("/app/tmp/stats.json", JSON.stringify(stats, null, 4))
    console.log('stats updated')
	return null
}

function processInstacartItems({ target, defaultLocation=null, uuid }){
    !target.endsWith("/") ? target+="/" : 0; 
    let storeRegex = /publix|aldi|kroger|dollargeneral|familydollar|fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    let allItems = []
    let allItemAttributes = []
    let allCollections = []
    let fullPrices = []
    let fullInventories = []
    let fullCollectionItemIds = []
    let files = fs.readdirSync(target, {encoding: 'utf8', withFileTypes: true})
    files = files.filter((d)=> d.isFile())
    for (let file of files){
        console.log(file.name)
        file.name.slice(-9, -5) === "aldi" ? defaultLocation="23170": defaultLocation;
        data = fs.readFileSync(target+file.name, {encoding: 'utf8'})
        data = JSON.parse(data)
        let collections = data.filter((d)=>d.url.includes('CollectionProducts'))
        let items = data.filter((d)=>d.url.includes('operationName=Items'))
        let itemAttributes = data.filter((d)=>d.url.includes('item_attributes'))
        let locationId = defaultLocation 
        console.log('collections.length', collections.length)
        console.log('items.length', items.length)
        console.log('item_attributes.length', itemAttributes.length)
        itemAttributes.map((d)=>{
            d.view.map((v)=>{
                fullPrices.push({
                    'utcTimestamp': new Date(d.acquisition_timestamp),
                    'item_id': v.trackingParams.item_id,
                    'quantity': 1,
                    'value': parseFloat(v.pricing.price.replace('$', '')),
                    'locationId': locationId,
                    'isPurchase': false
                });
                v.pricing.promotionEndsAt ? fullPrices.slice(-1)[0].expirationDate = new Date(v.pricing.promotionEndsAt) : v;
                allItemAttributes.push(cleanup(v))
            })
        })

        if (items.length > 0){
            items.map((d)=> {
                d.data.items.map((di)=>{
                    fullInventories.push({
                        'utcTimestamp': new Date(d.acquisition_timestamp),
                        'item_id': di.viewSection.trackingProperties.item_id,
                        'stockLevel': di.viewSection.trackingProperties.stock_level,
                        'locationId': locationId,
                        'availability_score': di.viewSection.trackingProperties.stock_level
                    })
                })
                allItems = allItems.concat(cleanup(d.data.items))
            })
        }
        if (collections.length > 0){
            collections.map((d)=>{
                d.data.collectionProducts.items.map((di)=>{
                    fullInventories.push({
                        'utcTimestamp': new Date(d.acquisition_timestamp),
                        'item_id': di.viewSection.trackingProperties.item_id,
                        'stockLevel': di.viewSection.trackingProperties.stock_level,
                        'locationId': locationId,
                        'availability_score': di.viewSection.trackingProperties.availability_score
                    })
                })
                fullCollectionItemIds = fullCollectionItemIds.concat(d.data.collectionProducts.itemIds)
                allItems = allItems.concat(cleanup(d.data.collectionProducts.items))
                let collections_entry = cleanup(d.data.collectionProducts.collection)
                collections_entry.itemIds = d.data.collectionProducts.itemIds;
                allCollections.push(collections_entry)
            })
        }

        let collectionProductsColumns = {
        'collection': ['id', 'name', 'slug', 'legacyPath', 'viewSection.trackingProperties.source_type/source_value/collection_type/collection_id/element_details.element_value/?parent_collection_id'],
        'items': ['id', 'name', 'size', 'productId', 'legacyId', 'legacyV3Id', 'quantityAttributes.quantityType/viewSection.unitString/unitAriaString',
        'availability.stockLevel', 'viewSection.itemImage.url/trackingProperties.element_details.product_id/retailer_location_id/?on_sale_ind./product_id,item_id,stock_level,availability_score,available_ind,?tags,?comboPromotions'],
        'itemAttributes': ['itemId', 'itemUpdatedAt', 'trackingParams.product_id/item_id/?policy_id/on_sale_ind.*/name/pricing.price/pricePerUnit/pricingUnit/productType/?promotionEndsAt/badge.*']
        }   
    }
    var toCollectionItems = []
    var uniqueItems = new Set()
    allItems.map((d)=> {
        if (!uniqueItems.has(d.id)){
            toCollectionItems.push({
                id: d.id,
                productId: d.productId,
                legacyId: d.legacyId,
                legacyV3Id: d.legacyV3Id,
                description: d.name,
                customerFacingSize: d.size,
                soldBy: d.quantityAttributes.viewSection.unitAriaString,
                images: [{url: d.viewSection.itemImage.url, perspective: 'front', main: true}],
            })
            d.tags ? toCollectionItems.slice(-1)[0].isStoreBrand = true : d;
            d.dietary ? 'attributeSections' in d.dietary.viewSection ? toCollectionItems.slice(-1)[0].dietary = d.dietary.viewSection.attributeSections.map((x)=>x.attributeString):  toCollectionItems.slice(-1)[0].dietary = d.dietary.viewSection.attributeString:  d;
            uniqueItems.add(d.id)
        }
    })


    allItemAttributes.map((d)=>{
        let matches = toCollectionItems.filter((y)=>y.legacyV3Id===d.itemId)
        if (matches.length>0){
            matches = matches[0]
            matches.pricingUnit ? matches.pricingUnit = d.pricing.pricingUnit : d;
            matches.productType = d.pricing.productType
            matches.priceAffix ? matches.priceAffix = d.pricing.priceAffix : d;
        }    
    })
    console.log(toCollectionItems.length, fullPrices.length, fullInventories.length)
    insertFilteredData(uuid, "items", toCollectionItems)
    insertData(fullPrices, 'prices')
    insertData(fullInventories, 'inventories')
    fs.mkdirSync('/app/tmp/data/collections/'+targetHeirarchy, {recursive: true})
    for (file of files){
        fs.renameSync(target+file.name, `/app/tmp/data/collections/${targetHeirarchy}`+file.name)
    }

    return null

}

function processFoodDepotItems({target}){
    /**
     * Decomposes Data Collected on Food Depot's 1st Party Site and Transforms them Into Parsed MongoDB Documents for Items & Prices Collections  
     */
    target.endsWith('/') ? target : target+="/";
    let files = fs.readdirSync(target, {encoding: 'utf-8', withFileTypes: true})
    files = files.filter((d)=>d.isFile())
    var storeRegex = /fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    targetHeirarchy.endsWith("/") ? targetHeirarchy : targetHeirarchy+="/"; 
    var totalData = []
    var allPrices = []
    var allItems = []
    var itemIdSet = new Set()
    itemAttributes = new Set(['categories', 'Id', 'ProductCatalogueId', 'images', 'sellBy', 'orderBy', 'description', 'nutrition', 'brand', 'taxGroupCode'])
    for (let file of files){
        console.log(file.name)
        data = fs.readFileSync(target+file.name, {encoding: 'utf8'})
        data = JSON.parse(data)
        totalData = totalData.concat(data)
        let items = data.filter((d)=>d.url.includes('products?'))
        for (let itemSet of items){
            let utcTimestamp = new Date(itemSet.acquisition_timestamp);
            let url = itemSet.url
            let path = url.split('/')
            let locationId = path[path.indexOf('stores')+1]
            itemSet = itemSet.Result.Products.map((d)=>cleanup(d))
            itemSet.map((item)=>{
                item.PriceSaving===0 ? allPrices.push({
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.Price*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: item.PriceType 
                }) : allPrices.push({
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.Price*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: item.PriceType
                }, {
                    isPurchase: false,
                    utcTimestamp: utcTimestamp,
                    value: Math.floor(item.PriceRegular*1.1*100)/100,
                    quantity: item.QuantityDefault,
                    id: item.Id,
                    locationId: locationId,
                    type: 'Regular'
                });
                if ('WeightPerUnit' in item){
                    allPrices.push({
                        isPurchase: false,
                        utcTimestamp: utcTimestamp,
                        value: Math.floor(item.UnitPrice*1.1*100)/100,
                        quantity: item.WeightPerUnit,
                        id: item.Id,
                        locationId: locationId,
                        type: 'Average'
                    })
                }

                item.categories = []
                item.Categories.map((d)=>{
                    if ('ParentCategoryId' in d){
                        item.categories.push({name: d.Name, id: d.Id})
                    } else {
                        item.categories.push({name: d.Name, id: d.Id})
                    }
                })
                item.images = [{url: item.ImageUrl, perspective: 'front', main: true, size: "medium"}]  
                delete item.ImageUrl
                item.desciption = item.Name;
                delete item.Name;
                if (item.IsSoldByWeight){
                    item.sellBy = 'WEIGHT'
                    item.orderBy = 'WEIGHT'    
                } else {
                    item.sellBy = 'UNIT'
                    item.orderBy = "UNIT"
                }
                
                if (item.Tags){
                    for (let tag of item.Tags){
                        if (tag.Name==='Brand'){
                            let brand = tag.Value.toLowerCase().trim().split(' ')
                            .map((word)=> {return word.charAt(0).toUpperCase() + word.slice(1)}).join(' ');
                            item.brand = brand
                        } else if (tag.Value==="Y") {
                            let nutritionalCategory = tag.Name.replace(' ', '')
                            item.nutrition===undefined ? item.nutrition = {} : 1; 
                            item.nutrition[nutritionalCategory] = true
                        }
                    }
                }

                item.taxGroupCode = item.TaxRate
                let itemDoc = {}
                Object.keys(item).filter((d)=>itemAttributes.has(d)).map((d)=> itemDoc[d]=item[d])
                if (!itemIdSet.has(itemDoc.Id)){
                    allItems.push(itemDoc)
                    itemIdSet.add(itemDoc.Id)
                }
                
            })
        }
    }
    insertFilteredData("Id", 'items', allItems)
    insertData(allPrices, 'prices')
    fs.mkdirSync('/app/tmp/data/collections/'+targetHeirarchy, {recursive: true})
    for (let file of files){
        fs.renameSync(target+file.name, `/app/tmp/data/collections/${targetHeirarchy}`+file.name)
    }

    return null
}

function processInternalCoupons({target, parser, uuid}){
    /**
     * Decomposes FamilyDollar, FoodDepot, and Publix 1st Party Promotions Through a Custom, User-Provided Parser and Inserts It into the DB
    */
    if (!parser){
        throw new Error('You Must Pass in a Parser to Parse!');
    }
    !target.endsWith("/") ? target+="/" : 0 ; 
    let files = fs.readdirSync(target, {encoding: 'utf-8', withFileTypes: true})
    files = files.filter((d)=>d.isFile())
    allCoupons = []
    let storesRegex = /fooddepot|publix|familydollar/
    var parserKeys = Object.keys(parser)
    let targetHeirarchy = target.match(storesRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    targetHeirarchy.endsWith("/") ? targetHeirarchy : targetHeirarchy+="/"; 
    for (let file of files){
        console.log(target+file.name, files.length)
        data = fs.readFileSync(target+file.name, {encoding: 'utf-8'})
        let chunk = JSON.parse(data)
        if (!Array.isArray(chunk)){
            chunk = [chunk]
        }
        chunk = chunk.filter((d)=> d.url.includes('savings') || d.url.includes('coupons') || d.url.includes('offers'))
        chunk.map((d)=> cleanup(d))
        if (target.includes('fooddepot')){
            chunk = chunk.filter((d)=>d.url.includes('appcard'))
            chunk = chunk.map((d)=>{return d.offers})
            chunk = chunk.flat()
        } else if (target.includes('publix')){
            chunk = chunk.map((c)=>{return c.Savings}).flat()
        } else {
            chunk = chunk.map((c)=>c.data).flat()
        }
        console.log("chunk length = ", chunk.length)
        chunk.map((d)=> {
            let newPromo = {}
            let relKeys = parserKeys.filter((pk)=> pk in d)
            for (let key of relKeys){
                let actions = parser[key]
                actions.convert ? d[key] = actions.convert(d[key]) : 0;
                actions.to ? actions.to in newPromo ? newPromo[actions.to] = [newPromo[actions.to], ...d[key]]: newPromo[actions.to] = d[key] : 0;
                actions.keep ? newPromo[key] = d[key] : 0;
            }
            allCoupons.push(newPromo)
        })
    }

    insertFilteredData(uuid, 'promotions', allCoupons, "new", false)
    fs.mkdirSync('/app/tmp/data/collections/'+targetHeirarchy, {recursive: true})
    for (let file of files){
        fs.renameSync(target+file.name, `/app/tmp/data/collections/${targetHeirarchy}`+file.name)
    }

    return null
}

function processFamilyDollarItems({target, defaultLocation="2394"}){
    // need new for family dollar items => prices, items, promotions<-items 
    var newParser = {
        combustible: {keep: true},
        made_in_usa: {keep: true},
        flammable: {keep: true},
        microwave_safe: {keep: true},
        bpa_free: {keep: true},
        dry_clean_only: {keep:true},
        dishwasher_safe: {keep: true},
        travel_size: {keep: true},
        food_safe: {keep: true},
        scent: {keep: true},
        flavor: {keep: true},
        wine_type: {keep:true},
        wine_varietal: {keep: true},
        id: {keep: "true"},
        description: {to: "romanceDescription", convert: function(x){return `<p>${x}</p>`}},
        minimum_quantity: {to: "minimumOrderQuantity"},
        categories: {to: "taxonomies", convert: function(x){
            let cats = x[0]
            let cparse = {"2": "department", "3": "commodity", "4": "subCommodity"}
            Object.keys(cats).map((k)=> {
            if (Object.keys(cparse).includes(k)){
                cats[cparse[k]] = cats[k]
                delete cats[k];
            } else {
                delete cats[k];
            }})
            return cats;
        }},
        UPCS: {to: "upc"},
        canonical: {to: "link"}
    }
    !target.endsWith("/") ? target+="/" : 0 ; 
    let storeRegex = /publix|aldi|kroger|dollargeneral|familydollar|fooddepot/
    let targetHeirarchy = target.match(storeRegex)
    targetHeirarchy = target.slice(targetHeirarchy.index)
    var allItems = []
    var allPrices = []
    let files = fs.readdirSync(target).map((d) => {
        let data = JSON.parse(fs.readFileSync(target+d)).map((x)=>cleanup(x))
        data=data.filter((d)=>"records" in d)
        data.map((z)=> z.records.map((r)=> r["utcTimestamp"]=z.acquisition_timestamp))
        allItems= allItems.concat(data.map((e)=>e.records).flat())
        allItems=allItems.filter((d)=>d)
        console.log(`parsed ${d}. ${allItems.length}`)

    })
    
    allItems = allItems.map((x)=> {
        let am =  x['allMeta']
        if ("badges" in am){
            let badges = am["badges"][0]
            delete am["badges"]
            am = {...am, ...badges}
        }
        delete x["allMeta"]
        let vv = am['visualVariant'][0]['nonvisualVariant'][0]
        delete am['visualVariant'];
        let attr = am['attributes'][0]
        delete am['attributes']
        x = {...am, ...vv, ...attr, ...x}
        Object.entries(x).map(([k, v])=> {if (v==="Y"){x[k]=true} else if (v==="N") {x[k]=false}})
        return x
    }).filter((d)=>"minimum_quantity" in d)
    
    allItems.map((d)=>{
        // minimumQuantity, Case, Sale if Exists
        allPrices.push({
            "quantity": d.minimum_quantity,
            locationId: defaultLocation, 
            isPurchase: false,
            utcTimestamp: new Date(d.utcTimestamp), 
            value: d.price
        })
        d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
        // for Case
        if (d.minimum_quantity != d.casepack){
            allPrices.push({
                "quantity": +d.casepack,
                locationId: defaultLocation, 
                isPurchase: false,
                utcTimestamp: new Date(d.utcTimestamp), 
                value: d.price
            })
            d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
        }

        if (d.sale_price && d.sale_price!=="0.00"){
            allPrices.push({
                "quantity": d.minimum_quantity,
                locationId: defaultLocation, 
                isPurchase: false,
                utcTimestamp: new Date(d.utcTimestamp), 
                value: d.sale_price
            })
            d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
            d.promo_price ? allPrices.slice(-1)[0]['type'] = d.promo_price : null ; 
            if (d.minimum_quantity!=d.casepack){
                allPrices.push({
                    "quantity": +d.casepack,
                    locationId: defaultLocation, 
                    isPurchase: false,
                    utcTimestamp: new Date(d.utcTimestamp), 
                    value: d.sale_price
                })
                d.upc ? allPrices.slice(-1)[0]['upc'] = d.upc : allPrices.slice(-1)[0]['id'] = d.id ;
                d.promo_price ? allPrices.slice(-1)[0]['type'] = d.promo_price : null ; 
            }
            
        }
    })

    allItems.map((x)=> {
        Object.keys(x).map((nk)=>{
            if (nk.startsWith("contains") || nk.startsWith("sugar") || nk.startsWith("gluten")){
                nk.endsWith("free") ? nk=nk.slice(0, -1): nk;
                let nutObj = {}
                if (nk.endsWith("free")){
                    let newKey = nk.split("_").map((str)=> str[0].toUpperCase() +str.slice(1))
                    nutObj[newKey] = x[nk]
                } else if (nk.startsWith("contains")){
                    let newKey = nk.split("_").slice(-1).map((str)=> str[0].toUpperCase() +str.slice(1) + "Free").join("")
                    nutObj[newKey] = !x[nk]
                }
                "nutrition" in x ? x["nutrition"] = {...x["nutrition"], ...nutObj}: x["nutrition"] = nutObj;
                delete x[nk]; 
            } else if (nk.startsWith("weight")){
                x["weight"] = x[nk]
                delete x[nk];
            } else if (nk.endsWith("_dimension")){ 
                let dimObj = {}
                dimObj[nk.replace("_dimension", "")] = x[nk]
                "dimensions" in x ? x["dimensions"] = {...x.dimensions, ...dimObj} : x["dimensions"] = dimObj;
                delete x[nk];
            } else if (nk === "available_in_store_only" && x[nk]){
                x["modalities"] = ["IN_STORE"]
                delete x[nk];
            } else if (nk === "call_center_only" && x[nk]){
                x["modalities"] = ["CALL_CENTER"]
                delete x[nk];
            } else if (nk==="brand"){
                brands = x[nk]
                x[nk] = brands.map((brand)=>{return{name:  brand.replaceAll(/&.+;/g, '')}})
            } else if (nk==="num_reviews" && x[nk]){
                x["ratings"] = {ct: x[nk], avg: x["average_rating"]}
                delete x[nk];
                delete x["average_rating"]
            } else if (nk==="name"){
                let name = x[nk]
                name = name.replace("?", "")
                let customerFacingSize = name.split(",").slice(1).filter((s)=>s.match(/\d+/g)!==null).map((match)=>{return match.trim()})
                x[nk] = name.split(",")[0]
                if (!customerFacingSize===""){
                    x["customerFacingSize"] = customerFacingSize.reverse().join(" / ")
                }
                x["description"] = x[nk]
                delete x[nk];
                
            } else if (Object.keys(newParser).includes(nk)){
                let actions = newParser[nk]
                if (newParser[nk].convert){
                    x[nk] = actions.convert(x[nk])
                }
                if (actions.to){
                    x[actions.to] = x[nk];
                }
                if (actions.keep===undefined){
                    delete x[nk]
                }

            } else {
                delete x[nk]
            }
            
        })
    })
    let idSet = new Set()
    allItems = allItems.filter((i)=>{
        if (idSet.has(i.id)){
            return false;
        } else {
            idSet.add(i.id)
            return true
        }
    })
    insertData(allPrices, "prices")
    insertFilteredData("id", "items", allItems)
    fs.mkdirSync('/app/tmp/data/collections/'+targetHeirarchy, {recursive: true})
    files = fs.readdirSync(target)
    for (let file of files){
       fs.renameSync(target+file, `/app/tmp/data/collections/${targetHeirarchy}`+file)
    }
    return null
}

function processDollarGeneralItems({target, couponParser, itemParser}){
    // Items from promotion scrapes currently: items => as defined below and prices and inventories
        // [description: String, upc: String, images: [{url: String | null, perspective: String, main: Boolean, size: String "xlarge" }]]
        // soldInStore: Boolean , IsBopisEligible: Boolean, modalities: Array = ["IN_STORE", "PICKUP", "SHIP"]
    let scrapedArray = new Array(); 
    if (!target.endsWith("/")) target+="/"; 
    let files = fs.readdirSync(target, {encoding: 'utf8', withFileTypes: true}).filter((d)=> d.isFile()).map((d)=> d.name);
    let targetHeirarchy = target.slice(target.indexOf("dollargeneral"))
    scrapedArray = files.map((d)=> JSON.parse(fs.readFileSync(target+d))).flat();

    var couponsForDB = [], items = [], prices=[], inventories=[], mapWithItemKeys={}, utcTimestamp, locationId, offerId;
    var itemsForDB = [];
    scrapedArray.sort((a, b) => {
        return a.url.includes("products") && !b.url.includes("products") ? -1 : 0; 
    })
    // separate coupons from items
    scrapedArray.filter((object)=> {
        if ("eligibleProductsResult" in object || 'categoriesResult' in object){
            // needs modalities, cleanup ratings
            items = object.eligibleProductsResult?.Items || object.categoriesResult?.ItemList.Items; 
            // products from coupon scrapes
            utcTimestamp = object.acquisition_timestamp;
            locationId = object.url.match(/(?:store|storeNumber)=(\d+)/)[1];
            if ("eligibleProductsResult" in object){
                offerId = object.url.match(/couponId=([^&]+)/);
            }
            // all items in list will belong to same location and offerId
            items.map((item)=> {
                item.UPC = String(item.UPC)
                item["modalities"] = itemParser["modalities"].create(item);
                if (offerId && offerId in mapWithItemKeys){
                    mapWithItemKeys[offerId].add(item.UPC)
                } else if (offerId) {
                    mapWithItemKeys[offerId] = new Set([item.UPC])
                 }
                let newItem = {};
                let relevantKeys = Object.keys(itemParser)
                for (key of relevantKeys){
                    let actions = itemParser[key]
                    if (key === "OfferID"){
                        item[key] = actions.convert(item[key], mapWithItemKeys)
                    } else if (key === "RatingReviewCount") {
                        item[key] = actions.convert(item[key], item["AverageRating"])
                    } else if (key === "_prices"){
                        prices = prices.concat(actions.convert(item, locationId, utcTimestamp))
                    } else if (key==="_inventories"){
                        inventories.push(actions.convert(item, locationId, utcTimestamp))
                    } else {
                        actions.convert && item[key]? item[key] = actions.convert(item[key]) : 0;
                    }
                
                    actions.to ? newItem[actions.to] = item[key] : 0;
                    actions.keep ? newItem[key] = item[key] : 0;
                    actions.bool && item[key] ? newItem[key] = item[key]: 0;
                };
                newItem = cleanup(newItem)
                itemsForDB.push(newItem)    

            })
        } else if ("Coupons" in object) {
            utcTimestamp = object.acquisition_timestamp;
            object.Coupons.map((coupon)=> {
                let newPromo = {};
                let relevantKeys = Object.keys(coupon).filter((c)=> c in couponParser)
                for (key of relevantKeys){
                    let actions = couponParser[key]
                    if (key === "OfferID"){
                        newPromo.id = coupon[key]
                        actions.convert ? coupon[key] = actions.convert(coupon[key], mapWithItemKeys) : 0;
                    } else if (key === "OfferDescription") {
                        actions.convert ? coupon[key] = actions.convert(coupon) : 0;
                    }
                    else {
                        actions.convert ? coupon[key] = actions.convert(coupon[key]) : 0;
                    }
                    
                    actions.to ? newPromo[actions.to] = coupon[key] : 0;
                    actions.keep ? newPromo[key] = coupon[key] : 0;
                    actions.bool && coupon[key] ? newPromo[actions.to] = coupon[key]: 0;
                };
                newPromo = cleanup(newPromo)
                couponsForDB.push(newPromo)    
            })

        }
    });
    //  will handle entering in items, prices, inventories from getDollarGeneralItems;
    // and handle entering in promotions, items, prices & inventories from getDollarGeneralCoupons;
    // promotions, items => insertFilteredData(id="id", collectionName="promotions", newData=this, dbName='new' )
    couponsForDB.length>0 ? insertFilteredData("id", "promotions", couponsForDB, "new", false): 0; 
    itemsForDB.length>0 ? insertFilteredData("upc", "items", itemsForDB, "new", false):0;
    prices.length>0 ? insertData(prices, "prices", false):0;
    inventories.length>0 ? insertData(inventories, "inventories", false):0;

    fs.mkdirSync('/app/tmp/data/collections/'+targetHeirarchy, {recursive: true})
    for (let file of files){
        fs.renameSync(target+file, `/app/tmp/data/collections/${targetHeirarchy}`+file)
    }
    return;
}

const program = new Command(); 

program
    .name("grocery-transform")
    .description("Transform and Normalize Preprocessed Data Scraped from Containerized Browser")
    .version("1.0.0");

program
    .command("transform")
    .description("processes grocery data and inserts normalized data into MongoDB")
    .option("--aldi <procedure>", "transform and insert instacart data for Aldi Stores")
    .option("--family-dollar <procedure>", "transform and insert instacartItems, items & promotions data for Family Dollar Stores")
    .option("--kroger <procedure>", "transform and insert promotions and trips for Kroger Stores")
    .option("--publix <procedure>", "transform and insert promotions and items for Publix Stores")
    .option("--dollar-general <procedure>", "transform and insert promotions and items for Dollar General Stores")
    .option("--food-depot <procedure>", "transform and insert promotions and items for Food Depot Stores")
    .action((options)=> {
        let [transformTask] = Object.entries(options).map(([k, v])=>{return k+v[0].toUpperCase()+v.slice(1)});
        console.log(transformTask)
        var transformerVars = {
            "foodDepotPromotions": {func: processInternalCoupons, args: {
                uuid: "targetOfferId",
                parser: {
                    "saveValue": {to: "value", convert: function (x) {return Number(x/100)}},
                    "expireDate": {to: "endDate", convert: function (x) {return new Date(x)}},
                    "effectiveDate": {to: "startDate", convert: function (x) {return new Date(x)}},
                    "offerId": {keep: true},
                    "targetOfferId": {keep: true},
                    "category": {to: "categories", convert: function(x) {return [x]}},
                    "image": {to: "imageUrl", convert: function (x){return x.links.lg}},
                    "brand": {to: "brandName"},
                    "details": {to: "terms"},
                    "offerType": {to: "type" }
                },
                target: "/app/tmp/collections/fooddepot/promotions/"
            }}, // target, parser, uuid="targetOfferId"
            "publixPromotions": {func: processInternalCoupons, args: {
                uuid: "id",
                parser: {
                    "id": {keep: true},
                    "dcId": {keep: true},
                    "waId": {keep: true},
                    "savings": {to: "value", convert: function(x){let n =  Number(x.replaceAll(/.+\$/g, '')); if (isNaN(n)){n=x} return n}},
                    "description": {to: "shortDescription"},
                    "redemptionsPerTransaction" : {to: "redemptionsAllowed"},
                    "minimumPurchase": {to: "requirementQuantity"},
                    "categories": {keep: true},
                    "imageUrl": {keep: true},
                    "brand": {to: "brandName"},
                    "savingType": {to: "type"},
                    "dc_popularity": {to: "popularity"}
                },
                target: "/app/tmp/collections/publix/promotions/"
            }}, //target, parser, uuid="id"
            "familyDollarPromotions": {func: processInternalCoupons, args:{
                uuid: "id", 
                parser: {
                    "mdid": {to: "id"},
                    "brand": {to: "brandName"},
                    "offerType": {to: "type"},
                    "description": {to: "shortDescription"},
                    "terms": {keep: true},
                    "category": {to: "categories", convert: (x)=>{
                        return x.name
                    }},
                    "tags": {to: "categories", convert: (x)=> {
                        return x.map((d)=>d.replace(/fd-/, '').trim().split('-').map((d)=>d[0].toUpperCase()+d.slice(1).toLowerCase()).join('-')).flat()
                    }},
                    "redemptionStartDateTime": {to: 'startDate', convert: (x)=> new Date(x.iso)},
                    "expirationDateTime": {to: 'expirationDate', convert: (x)=> new Date(x.iso)},
                    "clipStartDateTime": {to: 'clipStartDate', convert: (x)=> new Date(x.iso)},
                    "clipEndDateTime": {to: 'clipEndDate', convert: (x)=> new Date(x.iso)},
                    "offerSortValue": {to: 'value', convert: (x)=>+x},
                    "minPurchase": {to: 'requirementQuantity', convert: (x)=>+x},
                    "redemptionsPerTransaction": {to: 'redemptionsAllowed'},
                    "imageUrl": {keep: true},
                    "enhancedImageUrl": {keep: true},
                    "type": {to: "isManufacturerCoupon", convert: (x)=>x==="mfg"? true:false},
                    "popularity": {keep: true},
                    "clippedCount": {keep: true}
                
                },
                target: "/app/tmp/collections/familydollar/promotions/"
            }}, // target, parser, uuid="id"
            "dollarGeneralPromotions": {func: processDollarGeneralItems, args: {
                target: "/app/tmp/collections/dollargeneral/promotions/",
                couponParser: {
                    OfferCode: {to: "offerCode"},
                    OfferGS1: {to: "offerGS1", bool: true},
                    OfferDescription: {to: "shortDescription", convert: (x)=> {
                        if (x.OfferSummary.match(/^save/i)){
                            if (x.OfferDescription.match(/^on[^e]/i)) x.OfferDescription = " " + x.OfferDescription;
                            else x.OfferDescription = " on " + x.OfferDescription;
                            return x.OfferSummary + x.OfferDescription
                        } else {
                            return x.OfferDescription 
                        }
                    }},
                    BrandName: {to: "brandName"},
                    CompanyName: {to: "companyName"},
                    OfferType: {to: "offerType"},
                    OfferDisclaimer: {to: "terms", bool: true},
                    IsManufacturerCoupon: {to: "isManufacturerCoupon"},
                    RewaredCategoryName: {to: "categories"},
                    OfferActivationDate: {to: "startDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    OfferExpirationDate: {to: "expirationDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    RewaredOfferValue: {to: "value"},
                    MinQuantity: {to: "requirementQuantity"},
                    RedemptionLimitQuantity: {to: "redemptionsAllowed"},
                    RecemptionFrequency: {to: "redemptionFreq"},
                    Image1: {to: "imageUrl"},
                    Image2: {to: "imageUrl2"},
                    OfferID: {to:"productUpcs", convert: (offerId, mapWithItemKeys) => {
                        return offerId in mapWithItemKeys ? Array.from(mapWithItemKeys[offerId]) : [];
                    }}
                },
                itemParser: {
                    UPC: {to: "upc"},
                    Description: {to: "description"},
                    Image: {to: "images", convert: (img)=> {
                        return [{url: img, perspective: 'front', main: true, size: "xlarge"}]
                    }},
                    IsSellable: {to: "soldInStore"}, 
                    IsBopisEligible: { keep: 1},
                    IsGenericBrand: {keep: 1},
                    modalities: {create: (item)=> {
                        let mParse = {"IsSellable": "IN_STORE", "isShipToHome": "SHIP", "isPopshelfShipToHome": "SHIP", "IsBopisEligible": "PICKUP"}
                        return Object.entries(item).map(([k, v])=> {return k in mParse && v? k : 0;}).filter((k)=>k).map((truthyKey)=> {return mParse[truthyKey]})
                    }, to: "modalities"},
                    RatingReviewCount: {bool: 0, to: "ratings", convert: (ratingCount, ratingAverage)=> {
                        if (ratingCount){
                            return {avg: ratingAverage, ct: ratingCount}
                        }
                    }},
                    Categories: {bool:true, convert: (x)=> {
                        return x.split("|")
                    }},
                    _prices: {convert: (full_item, locationId, utcTimestamp) => { 
                        let returnValues = [];
                        returnValues.push({"value": full_item.OriginalPrice, "type": "Regular", "isPurchase": false,
                        "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                        modalities: full_item.modalities });
                        if (full_item.OriginalPrice !== full_item.Price){
                            returnValues.push({"value": full_item.Price, "type": "Sale", "isPurchase": false,
                            "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                            modalities: full_item.modalities });
                        }
                        return returnValues;
                    }},
                    _inventories: {convert: (full_item, locationId, utcTimestamp)=> {
                        let itemStatus = full_item.InventoryStatus; 
                        itemStatus = itemStatus ==1? "TEMPORARILY_OUT_OF_STOCK" : itemStatus == 2 ? "LOW" : "HIGH"; 
                        return {"stockLevel": itemStatus, "availableToSell": full_item.AvailableStockStore, "locationId": locationId,
                        "utcTimestamp": new Date(utcTimestamp), "upc": full_item.UPC}
                    }}
                }
            }},
            "dollarGeneralItems": {func: processDollarGeneralItems, args: {
                target: "/app/tmp/collections/dollargeneral/items/",
                couponParser: {
                    OfferCode: {to: "offerCode"},
                    OfferGS1: {to: "offerGS1", bool: true},
                    OfferDescription: {to: "shortDescription", convert: (x)=> {
                        if (x.OfferSummary.match(/^save/i)){
                            if (x.OfferDescription.match(/^on[^e]/i)) x.OfferDescription = " " + x.OfferDescription;
                            else x.OfferDescription = " on " + x.OfferDescription;
                            return x.OfferSummary + x.OfferDescription
                        } else {
                            return x.OfferDescription 
                        }
                    }},
                    BrandName: {to: "brandName"},
                    CompanyName: {to: "companyName"},
                    OfferType: {to: "offerType"},
                    OfferDisclaimer: {to: "terms", bool: true},
                    IsManufacturerCoupon: {to: "isManufacturerCoupon"},
                    RewaredCategoryName: {to: "categories"},
                    OfferActivationDate: {to: "startDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    OfferExpirationDate: {to: "expirationDate", convert: (dateMyTz)=> {return new Date(dateMyTz)}},
                    RewaredOfferValue: {to: "value"},
                    MinQuantity: {to: "requirementQuantity"},
                    RedemptionLimitQuantity: {to: "redemptionsAllowed"},
                    RecemptionFrequency: {to: "redemptionFreq"},
                    Image1: {to: "imageUrl"},
                    Image2: {to: "imageUrl2"},
                    OfferID: {to:"productUpcs", convert: (offerId, mapWithItemKeys) => {
                        return offerId in mapWithItemKeys ? Array.from(mapWithItemKeys[offerId]) : [];
                    }}
                },
                itemParser: {
                    UPC: {to: "upc"},
                    Description: {to: "description"},
                    Image: {to: "images", convert: (img)=> {
                        return [{url: img, perspective: 'front', main: true, size: "xlarge"}]
                    }},
                    IsSellable: {to: "soldInStore"}, 
                    IsBopisEligible: { keep: 1},
                    IsGenericBrand: {keep: 1},
                    modalities: {create: (item)=> {
                        let mParse = {"IsSellable": "IN_STORE", "isShipToHome": "SHIP", "isPopshelfShipToHome": "SHIP", "IsBopisEligible": "PICKUP"}
                        return Object.entries(item).map(([k, v])=> {return k in mParse && v? k : 0;}).filter((k)=>k).map((truthyKey)=> {return mParse[truthyKey]})
                    }, to: "modalities"},
                    RatingReviewCount: {bool: 0, to: "ratings", convert: (ratingCount, ratingAverage)=> {
                        if (ratingCount){
                            return {avg: ratingAverage, ct: ratingCount}
                        }
                    }},
                    Categories: {bool:true, convert: (x)=> {
                        return x.split("|")
                    }},
                    _prices: {convert: (full_item, locationId, utcTimestamp) => { 
                        let returnValues = [];
                        returnValues.push({"value": full_item.OriginalPrice, "type": "Regular", "isPurchase": false,
                        "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                        modalities: full_item.modalities });
                        if (full_item.OriginalPrice !== full_item.Price){
                            returnValues.push({"value": full_item.Price, "type": "Sale", "isPurchase": false,
                            "locationId": locationId, "utcTimestamp": utcTimestamp, "upc": full_item.UPC, "quantity": 1,
                            modalities: full_item.modalities });
                        }
                        return returnValues;
                    }},
                    _inventories: {convert: (full_item, locationId, utcTimestamp)=> {
                        let itemStatus = full_item.InventoryStatus; 
                        itemStatus = itemStatus ==1? "TEMPORARILY_OUT_OF_STOCK" : itemStatus == 2 ? "LOW" : "HIGH"; 
                        return {"stockLevel": itemStatus, "availableToSell": full_item.AvailableStockStore, "locationId": locationId,
                        "utcTimestamp": new Date(utcTimestamp), "upc": full_item.UPC}
                    }}
                }
            }},
            "familyDollarItems": {func: processFamilyDollarItems, args: {
                defaultLocation: "2394",
                target: "/app/tmp/collections/familydollar/items/"
            }},
            "familyDollarInstacartItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "2394",
                target: "/app/tmp/collections/familydollar/instacartItems/"
            }},
            "foodDepotItems": {func: processFoodDepotItems, args: {
                target: "/app/tmp/collections/fooddepot/items/"
            }},
            "publixItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "121659",
                target: "/app/tmp/collections/publix/items/"
            }}, 
            "aldiItems": {func: processInstacartItems, args: {
                uuid: "legacyId",
                defaultLocation: "23170",
                target: "/app/tmp/collections/aldi/items/"
            }} 
        };
        // run proper taskformer task with proper preconfigured arguments
        transformerVars[transformTask].func(transformerVars[transformTask].args)
        return null
    });

program.parse();